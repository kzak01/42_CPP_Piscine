---------------------------------ENG-------------------------------
								QuickSort

The quicksort is a sorting algorithm based on the "divide and conquer"
technique. It relies on the concept of partitioning, where an element
called the pivot is chosen from the list to be sorted.
The elements are then rearranged in such a way that the elements
smaller than the pivot are placed to the left of the pivot,
while the larger elements are placed to the right.
This partitioning process is performed recursively on the
two subsets of elements created by the pivot until each
subset contains only one element. At that point, the entire
list will be sorted.

Example:
Let's consider the following list of numbers to be sorted:
[7, 2, 1, 6, 8, 5, 3, 4]. We will use quicksort to sort them
in ascending order.

- Step 1: Select the pivot. We take the first element of the list,
which is 7.
- Step 2: Partitioning. We rearrange the elements so that the
elements smaller than 7 are to the left, and the larger elements
are to the right. After partitioning, the list might be:
[2, 1, 6, 5, 3, 4, 7, 8]. Now, the pivot is in its final
position, which is index 6.
- Step 3: Apply quicksort recursively to the two subsets
generated by the pivot. We start with the left subset
[2, 1, 6, 5, 3, 4] and repeat steps 1 and 2.
- Step 4: Select a new pivot for the left subset.
We take the first element, which is 2.
- Step 5: Partitioning of the left subset. After partitioning,
the left subset might be [1, 2, 6, 5, 3, 4].
The pivot 2 is in its final position, which is index 1.
- Step 6: Apply quicksort recursively to the two subsets
generated by the pivot 2. Both subsets contain only one element,
so they are considered already sorted.
- Step 7: Return to the original subset [7, 2, 1, 6, 8, 5, 3, 4]
and apply quicksort to the right subset [8, 5, 3, 4].
- Step 8: Select a new pivot for the right subset.
We take the first element, which is 8.
- Step 9: Partitioning of the right subset.
After partitioning, the right subset might be [4, 5, 3, 8].
The pivot 8 is in its final position, which is index 3.
- Step 10: Apply quicksort recursively to the two subsets
generated by the pivot 8. Both subsets contain only one element,
so they are considered already sorted.

At the end of this recursive process, we will have the
list completely sorted: [1, 2, 3, 4, 5, 6, 7, 8].

The quicksort is an efficient algorithm with an average
complexity of O(n log n), where n is the size of the list
to be sorted. However, its worst-case complexity can
reach O(n^2) if the chosen pivot does not balance the list
properly. Therefore, the correct implementation of the
partitioning is crucial to ensure optimal performance of
the quicksort.
---------------------------------ITA-------------------------------
								QuickSort

Il quicksort è un algoritmo di ordinamento basato sulla tecnica del
"divide et impera". Si basa sul concetto di partizionamento, in cui un
elemento, chiamato pivot, viene scelto dalla lista da ordinare
 Gli elementi vengono quindi riorganizzati in modo tale che gli
 elementi più piccoli del pivot siano posizionati a sinistra del pivot
 stesso, mentre gli elementi più grandi sono posizionati a destra.
 Questo processo di partizionamento viene eseguito ricorsivamente sui
 due sottoinsiemi di elementi creati dal pivot, fino a quando ogni
 sottoinsieme contiene un solo elemento. A quel punto, l'intera lista
 sarà stata ordinata.

Esempio:
Supponiamo di avere la seguente lista di numeri da ordinare:
[7, 2, 1, 6, 8, 5, 3, 4].
Utilizzeremo il quicksort per ordinarli in ordine crescente.

- Passo 1: Selezioniamo il pivot. Prendiamo il primo elemento della
lista, che è 7.
- Passo 2: Partizionamento. Riorganizziamo gli elementi in modo che gli
elementi minori di 7 siano a sinistra e gli elementi maggiori siano a
destra. Dopo il partizionamento, la lista potrebbe essere la seguente:
[2, 1, 6, 5, 3, 4, 7, 8]. Ora il pivot si trova nella sua posizione
finale, che è l'indice 6.
- Passo 3: Applichiamo il quicksort ricorsivamente ai due sottoinsiemi
generati dal pivot. Iniziamo con il sottoinsieme sinistro [2, 1, 6, 5,
3, 4] e ripetiamo i passi 1 e 2.
- Passo 4: Selezioniamo un nuovo pivot per il sottoinsieme sinistro.
Prendiamo il primo elemento, che è 2.
- Passo 5: Partizionamento del sottoinsieme sinistro. Dopo il
partizionamento, il sottoinsieme sinistro potrebbe essere
[1, 2, 6, 5, 3, 4]. Il pivot 2 si trova nella sua posizione finale,
che è l'indice 1.
- Passo 6: Applichiamo il quicksort ricorsivamente ai due sottoinsiemi
generati dal pivot 2. Entrambi i sottoinsiemi contengono un solo
elemento, quindi sono considerati già ordinati.
- Passo 7: Torniamo al sottoinsieme originale [7, 2, 1, 6, 8, 5, 3, 4] e
applichiamo il quicksort al sottoinsieme destro [8, 5, 3, 4].
- Passo 8: Selezioniamo un nuovo pivot per il sottoinsieme destro.
Prendiamo il primo elemento, che è 8.
- Passo 9: Partizionamento del sottoinsieme destro. Dopo il
partizionamento, il sottoinsieme destro potrebbe essere [4, 5, 3, 8].
Il pivot 8 si trova nella sua posizione finale, che è l'indice 3.
- Passo 10: Applichiamo il quicksort ricorsivamente ai due sottoinsiemi
generati dal pivot 8. Entrambi i sottoinsiemi contengono un solo
elemento, quindi sono considerati già ordinati.

Alla fine di questo processo ricorsivo, avremo la lista completamente
ordinata: [1, 2, 3, 4, 5, 6, 7, 8].

Il quicksort è un algoritmo efficiente con una complessità media di
O(n log n), dove n è la dimensione della lista da ordinare.
Tuttavia, la sua complessità peggiore può arrivare a O(n^2)
se il pivot scelto non bilancia correttamente la lista. Pertanto,
l'implementazione corretta del partizionamento è fondamentale per
garantire le prestazioni ottimali del quicksort.
