I misunderstood the subject. I thought I could use any sorting algorithm,
so I chose quicksort. Then I reread it and realized it was asking
for merge-insertion sort...

---------------------------------ENG-------------------------------
								QuickSort

The quicksort is a sorting algorithm based on the "divide and conquer"
technique. It relies on the concept of partitioning, where an element
called the pivot is chosen from the list to be sorted.
The elements are then rearranged in such a way that the elements
smaller than the pivot are placed to the left of the pivot,
while the larger elements are placed to the right.
This partitioning process is performed recursively on the
two subsets of elements created by the pivot until each
subset contains only one element. At that point, the entire
list will be sorted.

Example:
Let's consider the following list of numbers to be sorted:
[7, 2, 1, 6, 8, 5, 3, 4]. We will use quicksort to sort them
in ascending order.

- Step 1: Select the pivot. We take the first element of the list,
which is 7.
- Step 2: Partitioning. We rearrange the elements so that the
elements smaller than 7 are to the left, and the larger elements
are to the right. After partitioning, the list might be:
[2, 1, 6, 5, 3, 4, 7, 8]. Now, the pivot is in its final
position, which is index 6.
- Step 3: Apply quicksort recursively to the two subsets
generated by the pivot. We start with the left subset
[2, 1, 6, 5, 3, 4] and repeat steps 1 and 2.
- Step 4: Select a new pivot for the left subset.
We take the first element, which is 2.
- Step 5: Partitioning of the left subset. After partitioning,
the left subset might be [1, 2, 6, 5, 3, 4].
The pivot 2 is in its final position, which is index 1.
- Step 6: Apply quicksort recursively to the two subsets
generated by the pivot 2. Both subsets contain only one element,
so they are considered already sorted.
- Step 7: Return to the original subset [7, 2, 1, 6, 8, 5, 3, 4]
and apply quicksort to the right subset [8, 5, 3, 4].
- Step 8: Select a new pivot for the right subset.
We take the first element, which is 8.
- Step 9: Partitioning of the right subset.
After partitioning, the right subset might be [4, 5, 3, 8].
The pivot 8 is in its final position, which is index 3.
- Step 10: Apply quicksort recursively to the two subsets
generated by the pivot 8. Both subsets contain only one element,
so they are considered already sorted.

At the end of this recursive process, we will have the
list completely sorted: [1, 2, 3, 4, 5, 6, 7, 8].

The quicksort is an efficient algorithm with an average
complexity of O(n log n), where n is the size of the list
to be sorted. However, its worst-case complexity can
reach O(n^2) if the chosen pivot does not balance the list
properly. Therefore, the correct implementation of the
partitioning is crucial to ensure optimal performance of
the quicksort.

---------------------------------ITA-------------------------------
								QuickSort

Il quicksort è un algoritmo di ordinamento basato sulla tecnica del
"divide et impera". Si basa sul concetto di partizionamento, in cui un
elemento, chiamato pivot, viene scelto dalla lista da ordinare
 Gli elementi vengono quindi riorganizzati in modo tale che gli
 elementi più piccoli del pivot siano posizionati a sinistra del pivot
 stesso, mentre gli elementi più grandi sono posizionati a destra.
 Questo processo di partizionamento viene eseguito ricorsivamente sui
 due sottoinsiemi di elementi creati dal pivot, fino a quando ogni
 sottoinsieme contiene un solo elemento. A quel punto, l'intera lista
 sarà stata ordinata.

Esempio:
Supponiamo di avere la seguente lista di numeri da ordinare:
[7, 2, 1, 6, 8, 5, 3, 4].
Utilizzeremo il quicksort per ordinarli in ordine crescente.

- Passo 1: Selezioniamo il pivot. Prendiamo il primo elemento della
lista, che è 7.
- Passo 2: Partizionamento. Riorganizziamo gli elementi in modo che gli
elementi minori di 7 siano a sinistra e gli elementi maggiori siano a
destra. Dopo il partizionamento, la lista potrebbe essere la seguente:
[2, 1, 6, 5, 3, 4, 7, 8]. Ora il pivot si trova nella sua posizione
finale, che è l'indice 6.
- Passo 3: Applichiamo il quicksort ricorsivamente ai due sottoinsiemi
generati dal pivot. Iniziamo con il sottoinsieme sinistro [2, 1, 6, 5,
3, 4] e ripetiamo i passi 1 e 2.
- Passo 4: Selezioniamo un nuovo pivot per il sottoinsieme sinistro.
Prendiamo il primo elemento, che è 2.
- Passo 5: Partizionamento del sottoinsieme sinistro. Dopo il
partizionamento, il sottoinsieme sinistro potrebbe essere
[1, 2, 6, 5, 3, 4]. Il pivot 2 si trova nella sua posizione finale,
che è l'indice 1.
- Passo 6: Applichiamo il quicksort ricorsivamente ai due sottoinsiemi
generati dal pivot 2. Entrambi i sottoinsiemi contengono un solo
elemento, quindi sono considerati già ordinati.
- Passo 7: Torniamo al sottoinsieme originale [7, 2, 1, 6, 8, 5, 3, 4] e
applichiamo il quicksort al sottoinsieme destro [8, 5, 3, 4].
- Passo 8: Selezioniamo un nuovo pivot per il sottoinsieme destro.
Prendiamo il primo elemento, che è 8.
- Passo 9: Partizionamento del sottoinsieme destro. Dopo il
partizionamento, il sottoinsieme destro potrebbe essere [4, 5, 3, 8].
Il pivot 8 si trova nella sua posizione finale, che è l'indice 3.
- Passo 10: Applichiamo il quicksort ricorsivamente ai due sottoinsiemi
generati dal pivot 8. Entrambi i sottoinsiemi contengono un solo
elemento, quindi sono considerati già ordinati.

Alla fine di questo processo ricorsivo, avremo la lista completamente
ordinata: [1, 2, 3, 4, 5, 6, 7, 8].

Il quicksort è un algoritmo efficiente con una complessità media di
O(n log n), dove n è la dimensione della lista da ordinare.
Tuttavia, la sua complessità peggiore può arrivare a O(n^2)
se il pivot scelto non bilancia correttamente la lista. Pertanto,
l'implementazione corretta del partizionamento è fondamentale per
garantire le prestazioni ottimali del quicksort.

---------------------------------ENG-------------------------------
						MergeInsertionSort

The merge-insertion sort is a hybrid sorting algorithm
that combines the merge sort and insertion sort.
The main idea is to use the merge sort to divide the list
into smaller subsets and apply the insertion sort on
subsets with a size smaller than a specified threshold.
This approach leverages the speed of merge sort to handle
the majority of the sorting work, while the insertion
sort is used to optimize the sorting of smaller subsets.

Example:
Let's consider the following list of numbers to be sorted:
[7, 2, 1, 6, 8, 5, 3, 4]. We will use the merge-insertion
sort to sort them in ascending order.

Step 1: Divide the list into smaller subsets using the merge sort.
We divide the list into two subsets: [7, 2, 1, 6] and [8, 5, 3, 4].

Step 2: Apply the insertion sort on subsets with a size
smaller than the specified threshold.
We apply the insertion sort to the first subset [7, 2, 1, 6].
After sorting, the first subset becomes [1, 2, 6, 7].

Step 3: Merge the sorted subsets using the merge sort.
We merge the sorted subsets [1, 2, 6, 7] and [8, 5, 3, 4]
using the merge sort.
After the merge, we obtain the partially sorted list
[1, 2, 6, 7, 3, 4, 5, 8].

Step 4: Apply the insertion sort to the partially sorted list.
We apply the insertion sort to the partially sorted list
[1, 2, 6, 7, 3, 4, 5, 8].
After sorting, we obtain the completely sorted list
[1, 2, 3, 4, 5, 6, 7, 8].

The merge-insertion sort utilizes the efficiency of
merge sort for the majority of the sorting work,
while the insertion sort is used to optimize smaller subsets.
This approach can be particularly useful when the
list contains a combination of large and small subsets.

---------------------------------ITA-------------------------------
						MergeInsertionSort

Il merge-insertion sort è un algoritmo di ordinamento ibrido
che combina il merge sort e l'insertion sort. L'idea principale
è utilizzare il merge sort per suddividere la lista in sottoinsiemi
più piccoli e applicare l'insertion sort sui sottoinsiemi di
dimensione inferiore a una soglia specificata. Questo approccio
sfrutta la velocità di merge sort per gestire la maggior parte
del lavoro di ordinamento, mentre l'insertion sort viene utilizzato
per ottimizzare l'ordinamento dei sottoinsiemi più piccoli.

Esempio:
Supponiamo di avere la seguente lista di numeri da ordinare:
[7, 2, 1, 6, 8, 5, 3, 4]. Utilizzeremo il merge-insertion
sort per ordinarli in ordine crescente.

Passo 1: Dividiamo la lista in sottoinsiemi più piccoli
utilizzando il merge sort.
Suddividiamo la lista in due sottoinsiemi: [7, 2, 1, 6] e [8, 5, 3, 4].

Passo 2: Applichiamo l'insertion sort sui sottoinsiemi
di dimensione inferiore alla soglia specificata.
Applichiamo l'insertion sort al primo sottoinsieme [7, 2, 1, 6].
Dopo l'ordinamento, il primo sottoinsieme diventa [1, 2, 6, 7].

Passo 3: Riuniamo i sottoinsiemi ordinati utilizzando il merge sort.
Fondiamo i sottoinsiemi ordinati [1, 2, 6, 7] e [8, 5, 3, 4]
utilizzando il merge sort.
Dopo il merge, otteniamo la lista parzialmente ordinata
[1, 2, 6, 7, 3, 4, 5, 8].

Passo 4: Applichiamo l'insertion sort alla lista parzialmente ordinata.
Applichiamo l'insertion sort alla lista parzialmente ordinata
[1, 2, 6, 7, 3, 4, 5, 8].
Dopo l'ordinamento, otteniamo la lista completamente ordinata
[1, 2, 3, 4, 5, 6, 7, 8].

Il merge-insertion sort sfrutta l'efficienza del merge sort
per la maggior parte dell'ordinamento, mentre l'insertion sort
viene utilizzato per ottimizzare i sottoinsiemi più piccoli.
Questo approccio può essere particolarmente utile quando la
lista contiene una combinazione di grandi e piccoli sottoinsiemi.
